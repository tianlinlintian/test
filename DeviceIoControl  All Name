//获得当前进程可以打开驱动设备通信接口名字 要查看名字所在驱动可在DeviceIoControl调用之前设置了一个 __debugbreak()断点
//还需要设置cpu为单核，命中 __debugbreak()断点后继续对bp nt!IofCallDriver下断点然后按g放行
//nt!IofCallDriver断下后，一直按t单步跟，跟不了多久就会进入目标驱动的ioctl派遣函数（也就是nt!guard_dispatch_icall消失的时候）
//因为还有部分驱动在Createl派遣函数中也就是在打开设备时进行了了判断,
//比如WS2IFSL，需要调用NtCreateFile设置扩展属性,参见https://github.com/bluefrostsecurity/CVE-2019-1215/blob/master/CVE-2019-1215-ws2ifsl/exploit.cpp
//所以为了包含所有可能的结果即使在打开设备时出错但只要不是拒绝访问或者没有设置IRP_MJ_CREATE,设备无效就打印错误值 以及设备名，这种情况需要自己去分析
//关于ioctl定位通过对IofCompleteRequest交叉引用即可


#include "windows.h"
#include "stdio.h"

#pragma comment(lib,"ntdll.lib")

#define STATUS_BUFFER_TOO_SMALL 0xC0000023
#define STATUS_NO_MORE_ENTRIES 0x8000001A


typedef struct _UNICODE_STRING
{
	unsigned short Length;
	unsigned short MaxLength;
	unsigned long Pad;
	wchar_t* Buffer;
}UNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES {
	ULONGLONG           Length;
	HANDLE          RootDirectory;
	_UNICODE_STRING* ObjectName;
	ULONGLONG           Attributes;
	PVOID           SecurityDescriptor;
	PVOID           SecurityQualityOfService;
} OBJECT_ATTRIBUTES;



extern "C"
{
	int __stdcall ZwOpenDirectoryObject(HANDLE*, int DesiredAccess, _OBJECT_ATTRIBUTES*);
	int __stdcall ZwQueryDirectoryObject(HANDLE, void* Buffer, unsigned long BufferSize, BOOL ReturnSingleEntry, BOOL RestartScan, unsigned long* pContext, unsigned long* pReturnLength);
	int __stdcall ZwOpenSymbolicLinkObject(HANDLE* LinkHandle, int DesiredAccess, _OBJECT_ATTRIBUTES* ObjectAttributes);
	int __stdcall ZwQuerySymbolicLinkObject(HANDLE LinkHandle, _UNICODE_STRING* LinkTarget, unsigned long* ReturnedLength);

	int __stdcall ZwQueryObject(HANDLE, unsigned long Class, void* Buffer, unsigned long BufferSize, unsigned long* pReturnedLength);
	int __stdcall ZwClose(HANDLE);
}

wchar_t* Print_Level(int lvl)
{
	if (!lvl) return (WCHAR*)L"";
	else if (lvl == 1) return (WCHAR*)L"=>";
	else if (lvl == 2) return (WCHAR*)L"==>";

	wchar_t X = '=';

	wchar_t* p = (wchar_t*)LocalAlloc(LMEM_ZEROINIT, (lvl * 2) + 2 + 2); //Never freed, fix later

	int lvl_x = lvl, i = 0;

	while (lvl_x--) p[i++] = X;
	p[i] = '>';
	return p;
}

BOOL ShouldConcat(wchar_t* pStr)
{
	if (!pStr) return FALSE;
	unsigned long Len = wcslen(pStr);
	if (Len)
	{
		if (pStr[Len - 1] == '\\') return FALSE;
	}

	return TRUE;
}

int Recur(HANDLE hDirectory, wchar_t* DirName, int LevelX)
{
	unsigned long BufSize = 0;
	void* Buffer = 0;

	unsigned long Context = 0;
	int ret = 0;
	WCHAR path[MAX_PATH] = { 0 };
	while (ret >= 0)
	{

		unsigned long ReturnLength = 0;
		ret = ZwQueryDirectoryObject(hDirectory, 0, 0, TRUE, FALSE, &Context, &ReturnLength);
		//	wprintf(L"%s ret: %X, Context: %X, ReturnLength: %X\r\n",Print_Level(LevelX),ret,Context,ReturnLength);




		if (ret == STATUS_BUFFER_TOO_SMALL)
		{
			BufSize = ReturnLength;
			Buffer = LocalAlloc(LMEM_ZEROINIT, BufSize);
			ret = ZwQueryDirectoryObject(hDirectory, Buffer, BufSize, TRUE, FALSE, &Context, &ReturnLength);

			//	wprintf(L"%s ret: %X, Context: %X, ReturnLength: %X\r\n",Print_Level(LevelX),ret,Context,ReturnLength);

			_UNICODE_STRING* pUni = (_UNICODE_STRING*)Buffer;

			char* StartBuffer = (char*)Buffer;
			char* EndBuffer = ((char*)Buffer) + ReturnLength;

			char* Cur = (char*)pUni;

			char* Str1 = (char*)(pUni->Buffer);
			unsigned long Len1 = pUni->MaxLength;


			char* Str2 = (char*)((pUni + 1)->Buffer);
			unsigned long Len2 = (pUni + 1)->MaxLength;

			if ((Cur >= StartBuffer) && (Cur + (sizeof(_UNICODE_STRING) * 2) <= EndBuffer) /*At least two _UNICODE_STRING structures*/
				&&
				(Str1 >= StartBuffer) && (Str1 + Len1 <= EndBuffer)
				&&
				(Str2 >= StartBuffer) && (Str2 + Len2 <= EndBuffer))
			{
				wchar_t* Name = 0, * Type = 0;
				if (pUni->Length != 0 && pUni->MaxLength != 0 && pUni->Buffer != 0) Name = pUni->Buffer;
				pUni++;
				if (pUni->Length != 0 && pUni->MaxLength != 0 && pUni->Buffer != 0) Type = pUni->Buffer;
				wchar_t FullObjName[MAX_PATH + 1] = { 0 };
				if (Name && Type && !_wcsicmp(Type, L"Device"))
				{

					//	wprintf(L"%s Name: %s, Type: %s\r\n", Print_Level(LevelX), Name, Type);

					wcscpy_s(FullObjName, DirName);
					wcscat_s(FullObjName, Name);
					memcpy_s(path, MAX_PATH, L"\\\\.\\GLOBALROOT\\Device", MAX_PATH);
					wcscat_s(path, FullObjName);
					HANDLE hDriver = CreateFileW(path, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);

					
					if (hDriver != INVALID_HANDLE_VALUE) {
						printf("%S\n", path);
					}
					else if (GetLastError() > 5 && GetLastError() != 31)
					{
						printf("%S   需要进一步分析，错误值%d\n", path, GetLastError());
					}
					memset(path, 0, MAX_PATH);
					//wprintf(L"%s\n", FullObjName);
				}

				if (!_wcsicmp(Type, L"Directory"))
				{
					_UNICODE_STRING UNI_S = { 0 };

					wchar_t* Dir_S = Name;

					UNI_S.Length = wcslen(Dir_S) * 2;
					UNI_S.MaxLength = UNI_S.Length + 2;
					UNI_S.Buffer = Dir_S;

					_OBJECT_ATTRIBUTES ObjAttr_S = { sizeof(ObjAttr_S) };
					ObjAttr_S.RootDirectory = hDirectory;
					ObjAttr_S.ObjectName = &UNI_S;
					ObjAttr_S.Attributes = 0x40;

					HANDLE hDir_S = 0;
					int ret_S = ZwOpenDirectoryObject(&hDir_S, 0x20001, &ObjAttr_S);

					if (ret_S < 0)
					{
					}
					else
					{
						if (ShouldConcat(FullObjName)) wcscat_s(FullObjName, L"\\");
						int R = Recur(hDir_S, FullObjName, LevelX + 1);
						ZwClose(hDir_S);
					}
				}

			}
		}
	}

	return 0;
}

int main()
{

	_UNICODE_STRING UNI = { 0 };
	wchar_t* Dir = (WCHAR*)L"\\";
	UNI.Length = wcslen(Dir) * 2;
	UNI.MaxLength = UNI.Length + 2;
	UNI.Buffer = Dir;

	_OBJECT_ATTRIBUTES ObjAttr = { sizeof(ObjAttr) };
	ObjAttr.ObjectName = &UNI;
	ObjAttr.Attributes = 0x40;

	HANDLE hDir = 0;
	int ret = ZwOpenDirectoryObject(&hDir, 0x20001, &ObjAttr);
	wprintf(L"ZwOpenDirectoryObject, ret: %X, HANDLE: %X\r\n", ret, hDir);

	if (ret >= 0)
	{
		Recur(hDir, (WCHAR*)L"\\", 1);
		ZwClose(hDir);
	}

	char* buf = (char*)malloc(0xffffff);
	char path[MAX_PATH] = { 0 };
	HANDLE hDriver = NULL;
	memset(buf, 0, 0xffffff);

	QueryDosDeviceA(NULL, buf, 0xffffff);

	for (size_t i = 0; i < 0xffffff; i++)
	{
		if (buf[i] == 0 && buf[i + 1] != 0)
		{
			memcpy_s(path, MAX_PATH, "\\\\.\\", MAX_PATH);
			char* test = &buf[i + 1];
			strcat_s(path, test);

			hDriver = CreateFileA(path, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
			
			if (hDriver != INVALID_HANDLE_VALUE) {
				printf("%s\n", path);
			}
			else if (GetLastError() > 5&& GetLastError()!=31)
			{
				printf("%s   需要进一步分析，错误值%d\n", path, GetLastError());
			}
			memset(path, 0, MAX_PATH);

		}
	}

	return 0;
}
