#include "windows.h"
#include "stdio.h"
//跑个通信接口名字 就图个方便 要查看名字所在驱动可在DeviceIoControl调用之前设置了一个 __debugbreak()断点
//另外还需要设置cpu为单核，命中 __debugbreak()断点后继续对bp nt!IofCallDriver下断点然后按g放行
//nt!IofCallDriver断下后，一直按t单步跟，跟不了多久就会进入目标驱动的ioctl派遣函数（也就是nt!guard_dispatch_icall消失的时候）
#pragma comment(lib,"ntdll.lib")

#define STATUS_BUFFER_TOO_SMALL 0xC0000023
#define STATUS_NO_MORE_ENTRIES 0x8000001A


typedef struct _UNICODE_STRING
{
	unsigned short Length;
	unsigned short MaxLength;
	unsigned long Pad;
	wchar_t* Buffer;
}UNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES {
	ULONGLONG           Length;
	HANDLE          RootDirectory;
	_UNICODE_STRING* ObjectName;
	ULONGLONG           Attributes;
	PVOID           SecurityDescriptor;
	PVOID           SecurityQualityOfService;
} OBJECT_ATTRIBUTES;



extern "C"
{
	int __stdcall ZwOpenDirectoryObject(HANDLE*, int DesiredAccess, _OBJECT_ATTRIBUTES*);
	int __stdcall ZwQueryDirectoryObject(HANDLE, void* Buffer, unsigned long BufferSize, BOOL ReturnSingleEntry, BOOL RestartScan, unsigned long* pContext, unsigned long* pReturnLength);
	int __stdcall ZwOpenSymbolicLinkObject(HANDLE* LinkHandle, int DesiredAccess, _OBJECT_ATTRIBUTES* ObjectAttributes);
	int __stdcall ZwQuerySymbolicLinkObject(HANDLE LinkHandle, _UNICODE_STRING* LinkTarget, unsigned long* ReturnedLength);

	int __stdcall ZwQueryObject(HANDLE, unsigned long Class, void* Buffer, unsigned long BufferSize, unsigned long* pReturnedLength);
	int __stdcall ZwClose(HANDLE);
}

wchar_t* Print_Level(int lvl)
{
	if (!lvl) return (WCHAR*)L"";
	else if (lvl == 1) return (WCHAR*)L"=>";
	else if (lvl == 2) return (WCHAR*)L"==>";

	wchar_t X = '=';

	wchar_t* p = (wchar_t*)LocalAlloc(LMEM_ZEROINIT, (lvl * 2) + 2 + 2); //Never freed, fix later

	int lvl_x = lvl, i = 0;

	while (lvl_x--) p[i++] = X;
	p[i] = '>';
	return p;
}

BOOL ShouldConcat(wchar_t* pStr)
{
	if (!pStr) return FALSE;
	unsigned long Len = wcslen(pStr);
	if (Len)
	{
		if (pStr[Len - 1] == '\\') return FALSE;
	}

	return TRUE;
}

int Recur(HANDLE hDirectory, wchar_t* DirName, int LevelX)
{
	unsigned long BufSize = 0;
	void* Buffer = 0;

	unsigned long Context = 0;
	int ret = 0;
	WCHAR path[MAX_PATH] = { 0 };
	while (ret >= 0)
	{

		unsigned long ReturnLength = 0;
		ret = ZwQueryDirectoryObject(hDirectory, 0, 0, TRUE, FALSE, &Context, &ReturnLength);
		//	wprintf(L"%s ret: %X, Context: %X, ReturnLength: %X\r\n",Print_Level(LevelX),ret,Context,ReturnLength);




		if (ret == STATUS_BUFFER_TOO_SMALL)
		{
			BufSize = ReturnLength;
			Buffer = LocalAlloc(LMEM_ZEROINIT, BufSize);
			ret = ZwQueryDirectoryObject(hDirectory, Buffer, BufSize, TRUE, FALSE, &Context, &ReturnLength);

			//	wprintf(L"%s ret: %X, Context: %X, ReturnLength: %X\r\n",Print_Level(LevelX),ret,Context,ReturnLength);

			_UNICODE_STRING* pUni = (_UNICODE_STRING*)Buffer;

			char* StartBuffer = (char*)Buffer;
			char* EndBuffer = ((char*)Buffer) + ReturnLength;

			char* Cur = (char*)pUni;

			char* Str1 = (char*)(pUni->Buffer);
			unsigned long Len1 = pUni->MaxLength;


			char* Str2 = (char*)((pUni + 1)->Buffer);
			unsigned long Len2 = (pUni + 1)->MaxLength;

			if ((Cur >= StartBuffer) && (Cur + (sizeof(_UNICODE_STRING) * 2) <= EndBuffer) /*At least two _UNICODE_STRING structures*/
				&&
				(Str1 >= StartBuffer) && (Str1 + Len1 <= EndBuffer)
				&&
				(Str2 >= StartBuffer) && (Str2 + Len2 <= EndBuffer))
			{
				wchar_t* Name = 0, * Type = 0;
				if (pUni->Length != 0 && pUni->MaxLength != 0 && pUni->Buffer != 0) Name = pUni->Buffer;
				pUni++;
				if (pUni->Length != 0 && pUni->MaxLength != 0 && pUni->Buffer != 0) Type = pUni->Buffer;
				wchar_t FullObjName[MAX_PATH + 1] = { 0 };
				if (Name && Type&& !_wcsicmp(Type, L"Device"))
				{
					
				//	wprintf(L"%s Name: %s, Type: %s\r\n", Print_Level(LevelX), Name, Type);

					wcscpy_s(FullObjName, DirName);
					wcscat_s(FullObjName, Name);
					memcpy_s(path, MAX_PATH, L"\\\\.\\GLOBALROOT\\Device", MAX_PATH);
					wcscat_s(path, FullObjName);
					HANDLE hDriver = CreateFileW(path, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);

					if (hDriver != INVALID_HANDLE_VALUE) {
						printf("%S\n", path);
					}
					memset(path, 0, MAX_PATH);
					//wprintf(L"%s\n", FullObjName);
				}

				if (!_wcsicmp(Type, L"Directory"))
				{
					_UNICODE_STRING UNI_S = { 0 };

					wchar_t* Dir_S = Name;

					UNI_S.Length = wcslen(Dir_S) * 2;
					UNI_S.MaxLength = UNI_S.Length + 2;
					UNI_S.Buffer = Dir_S;

					_OBJECT_ATTRIBUTES ObjAttr_S = { sizeof(ObjAttr_S) };
					ObjAttr_S.RootDirectory = hDirectory;
					ObjAttr_S.ObjectName = &UNI_S;
					ObjAttr_S.Attributes = 0x40;

					HANDLE hDir_S = 0;
					int ret_S = ZwOpenDirectoryObject(&hDir_S, 0x20001, &ObjAttr_S);
					
					if (ret_S < 0)
					{
					}
					else
					{
						if (ShouldConcat(FullObjName)) wcscat_s(FullObjName, L"\\");
						int R = Recur(hDir_S, FullObjName, LevelX + 1);
						ZwClose(hDir_S);
					}
				}

			}
		}
	}

	return 0;
}

int main()
{

	_UNICODE_STRING UNI = { 0 };
	wchar_t* Dir = (WCHAR*)L"\\";
	UNI.Length = wcslen(Dir) * 2;
	UNI.MaxLength = UNI.Length + 2;
	UNI.Buffer = Dir;

	_OBJECT_ATTRIBUTES ObjAttr = { sizeof(ObjAttr) };
	ObjAttr.ObjectName = &UNI;
	ObjAttr.Attributes = 0x40;

	HANDLE hDir = 0;
	int ret = ZwOpenDirectoryObject(&hDir, 0x20001, &ObjAttr);
	wprintf(L"ZwOpenDirectoryObject, ret: %X, HANDLE: %X\r\n", ret, hDir);

	if (ret >= 0)
	{
		Recur(hDir, (WCHAR*)L"\\", 1);
		ZwClose(hDir);
	}

	char* buf = (char*)malloc(0xffffff);
	char path[MAX_PATH] = { 0 };
	HANDLE hDriver = NULL;
	memset(buf, 0, 0xffffff);

	QueryDosDeviceA(NULL, buf, 0xffffff);

	for (size_t i = 0; i < 0xffffff; i++)
	{
		if (buf[i] == 0 && buf[i + 1] != 0)
		{
			memcpy_s(path, MAX_PATH, "\\\\.\\", MAX_PATH);
			char* test = &buf[i + 1];
			strcat_s(path, test);

			hDriver = CreateFileA(path, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
			
			if (hDriver != INVALID_HANDLE_VALUE) {
				printf("%s\n", path);
			}
			memset(path, 0, MAX_PATH);

		}
	}

	return 0;
}
